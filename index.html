# arquivo: bet_ai_poc.py
# pip install requests pandas scikit-learn lightgbm numpy

import os, math, time, requests
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
import numpy as np

ODDS_API_KEY = os.getenv("ODDS_API_KEY")  # defina antes de rodar

def fetch_odds_sport(sport="soccer_epl", region="eu"):
    url = f"https://api.the-odds-api.com/v4/sports/{sport}/odds/"
    params = {"regions": region, "markets":"h2h", "oddsFormat":"decimal", "dateFormat":"iso"}
    headers = {"x-api-key": ODDS_API_KEY}
    r = requests.get(url, params=params, headers=headers, timeout=15)
    r.raise_for_status()
    return r.json()

def normalize_event(event):
    # exemplo simplificado: extrai time A vs B e odds média dos bookmakers
    teams = event.get("teams", [])
    bookmakers = event.get("bookmakers", [])
    if not bookmakers: return None
    # pegar primeiro bookmaker ou média
    odds_list = []
    for b in bookmakers:
        for m in b.get("markets", []):
            if m["key"] == "h2h":
                # m['outcomes'] -> lista com nome & price
                prices = {o['name']: o['price'] for o in m['outcomes']}
                odds_list.append(prices)
    if not odds_list: return None
    # média das odds (por nome)
    df = pd.DataFrame(odds_list).T
    avg_odds = df.mean(axis=1).to_dict()
    return {
        "id": event.get("id"),
        "teams": teams,
        "commence_time": event.get("commence_time"),
        "odds": avg_odds
    }

def implied_prob(decimal_odds):
    return 1.0 / decimal_odds

def kelly_fraction(p, b):
    # p = model probability of win, b = decimal odds - 1 (net odds)
    if p == 0 or b <= 0: return 0.0
    k = (p*(b+1) - 1) / b
    return max(0.0, k)

# POC: pipeline
def run_poc():
    raw = fetch_odds_sport(sport="soccer_epl", region="uk")
    events = [normalize_event(e) for e in raw]
    events = [e for e in events if e]
    rows = []
    for e in events:
        if len(e["teams"]) < 2: continue
        team_a, team_b = e["teams"][0], e["teams"][1]
        odds = e["odds"]
        # Espera-se odds com chaves correspondentes aos nomes; simplificação:
        for team_name, odd in odds.items():
            rows.append({"event_id": e["id"], "team": team_name, "odd": odd})
    df = pd.DataFrame(rows)
    if df.empty:
        print("Sem eventos/odds.")
        return
    # Criar features fictícias: usar odds inversas como proxy de expectativa do mercado
    df["market_prob"] = df["odd"].apply(implied_prob)
    # Simular label histórico (somente POC): usar ruído aleatório para treinar
    np.random.seed(1)
    df["label"] = (np.random.rand(len(df)) < df["market_prob"]*0.95).astype(int)

    X = df[["market_prob"]]
    y = df["label"]
    X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=42)
    model = LogisticRegression().fit(X_train, y_train)
    df["model_p"] = model.predict_proba(df[["market_prob"]])[:,1]

    # Calcular valor e stake via Kelly fracionado (0.25)
    bank = 1000.0
    bets = []
    for _, r in df.iterrows():
        p = r["model_p"]
        b = r["odd"] - 1.0
        k = kelly_fraction(p,b)
        k_frac = 0.25 * k
        stake = bank * k_frac
        # EV estimado simplificado: p*(odd-1) - (1-p)
        ev = p*(r["odd"]-1) - (1-p)
        if ev > 0 and stake > 0.01:
            bets.append({
                "team": r["team"], "odd": r["odd"], "p_model": round(p,3),
                "ev": round(ev,4), "stake": round(stake,2)
            })
    bets_sorted = sorted(bets, key=lambda x: x["ev"], reverse=True)
    print("Recomendações (POC):")
    for b in bets_sorted[:10]:
        print(b)
    return bets_sorted

if __name__ == "__main__":
    if not ODDS_API_KEY:
        raise SystemExit("Defina a variável de ambiente ODDS_API_KEY com sua chave.")
    run_poc()
